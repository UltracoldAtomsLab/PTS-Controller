
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module sequencer_extensions(

    //////////// CLOCK //////////
    CLOCK_50,

    //////////// LED //////////
    LED,

    //////////// KEY //////////
    KEY,

    //////////// SW //////////
    SW,

    //////////// SDRAM //////////
    DRAM_ADDR,
    DRAM_BA,
    DRAM_CAS_N,
    DRAM_CKE,
    DRAM_CLK,
    DRAM_CS_N,
    DRAM_DQ,
    DRAM_DQM,
    DRAM_RAS_N,
    DRAM_WE_N,

    //////////// EPCS //////////
    EPCS_ASDO,
    EPCS_DATA0,
    EPCS_DCLK,
    EPCS_NCSO,

    //////////// Accelerometer and EEPROM //////////
    G_SENSOR_CS_N,
    G_SENSOR_INT,
    I2C_SCLK,
    I2C_SDAT,

    //////////// ADC //////////
    ADC_CS_N,
    ADC_SADDR,
    ADC_SCLK,
    ADC_SDAT,

    //////////// 2x13 GPIO Header //////////
    GPIO_2,
    GPIO_2_IN,

    //////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
    GPIO_0,
    GPIO_0_IN,

    //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
    GPIO_1,
    GPIO_1_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input                       CLOCK_50;

//////////// LED //////////
output           [7:0]      LED;

//////////// KEY //////////
input            [1:0]      KEY;

//////////// SW //////////
input            [3:0]      SW;

//////////// SDRAM //////////
output          [12:0]      DRAM_ADDR;
output           [1:0]      DRAM_BA;
output                      DRAM_CAS_N;
output                      DRAM_CKE;
output                      DRAM_CLK;
output                      DRAM_CS_N;
inout           [15:0]      DRAM_DQ;
output           [1:0]      DRAM_DQM;
output                      DRAM_RAS_N;
output                      DRAM_WE_N;

//////////// EPCS //////////
output                      EPCS_ASDO;
input                       EPCS_DATA0;
output                      EPCS_DCLK;
output                      EPCS_NCSO;

//////////// Accelerometer and EEPROM //////////
output                      G_SENSOR_CS_N;
input                       G_SENSOR_INT;
output                      I2C_SCLK;
inout                       I2C_SDAT;

//////////// ADC //////////
output                      ADC_CS_N;
output                      ADC_SADDR;
output                      ADC_SCLK;
input                       ADC_SDAT;

//////////// 2x13 GPIO Header //////////
inout           [12:0]      GPIO_2;
input            [2:0]      GPIO_2_IN;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout           [33:0]      GPIO_0;
input            [1:0]      GPIO_0_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout           [33:0]      GPIO_1;
input            [1:0]      GPIO_1_IN;


//=======================================================
//  REG/WIRE declarations
//=======================================================
wire                        vjtag_tck;
wire                        vjtag_tdi;
wire                        vjtag_irin;
wire                        vjtag_cdr;
wire                        vjtag_cir;
wire                        vjtag_e1dr;
wire                        vjtag_e2dr;
wire                        vjtag_pdr;
wire                        vjtag_sdr;
wire                        vjtag_udr;
wire                        vjtag_uir;
wire                        vjtag_tdo;
wire             [7:0]      PC_data;
wire                        PC_flag;

reg                         nRst;
reg              [7:0]      reset_count;

//=======================================================
//  Structural coding
//=======================================================
always @ (*) begin
	//nRst = KEY[0] && (reset_count==0) && line_reset;
	nRst = KEY[0] && (reset_count==0);
end
//assign line_reset = GPIO_0_IN[0];

VJTAG vjtag0(
    .ir_out(),
    .tdo(vjtag_tdo),
    .ir_in(vjtag_irin),
    .tck(vjtag_tck),
    .tdi(vjtag_tdi),
    .virtual_state_cdr(vjtag_cdr),
    .virtual_state_cir(vjtag_cir),
    .virtual_state_e1dr(vjtag_e1dr),
    .virtual_state_e2dr(vjtag_e2dr),
    .virtual_state_pdr(vjtag_pdr),
    .virtual_state_sdr(vjtag_sdr),
    .virtual_state_udr(vjtag_udr),
    .virtual_state_uir(vjtag_uir)
);
    
vJTAG_interface vjtag_i0(
    .tck(vjtag_tck),
    .tdi(vjtag_tdi),
    .aclr(!nRst),
    .ir_in(vjtag_irin),
    .v_sdr(vjtag_sdr),
    .udr(vjtag_udr),
    
    .DR(PC_data),
    .tdo(vjtag_tdo),
    
    .iCLOCK_50(CLOCK_50),
    .oFLAG(PC_flag)
);

endmodule
