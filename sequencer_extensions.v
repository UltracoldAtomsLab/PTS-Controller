
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module sequencer_extensions(

    //////////// CLOCK //////////
    CLOCK_50,

    //////////// LED //////////
    LED,

    //////////// KEY //////////
    KEY,

    //////////// SW //////////
    SW,

    //////////// SDRAM //////////
    DRAM_ADDR,
    DRAM_BA,
    DRAM_CAS_N,
    DRAM_CKE,
    DRAM_CLK,
    DRAM_CS_N,
    DRAM_DQ,
    DRAM_DQM,
    DRAM_RAS_N,
    DRAM_WE_N,

    //////////// EPCS //////////
    EPCS_ASDO,
    EPCS_DATA0,
    EPCS_DCLK,
    EPCS_NCSO,

    //////////// Accelerometer and EEPROM //////////
    G_SENSOR_CS_N,
    G_SENSOR_INT,
    I2C_SCLK,
    I2C_SDAT,

    //////////// ADC //////////
    ADC_CS_N,
    ADC_SADDR,
    ADC_SCLK,
    ADC_SDAT,

    //////////// 2x13 GPIO Header //////////
    GPIO_2,
    GPIO_2_IN,

    //////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
    GPIO_0,
    GPIO_0_IN,

    //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
    GPIO_1,
    GPIO_1_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input                       CLOCK_50;

//////////// LED //////////
output           [7:0]      LED;

//////////// KEY //////////
input            [1:0]      KEY;

//////////// SW //////////
input            [3:0]      SW;

//////////// SDRAM //////////
output          [12:0]      DRAM_ADDR;
output           [1:0]      DRAM_BA;
output                      DRAM_CAS_N;
output                      DRAM_CKE;
output                      DRAM_CLK;
output                      DRAM_CS_N;
inout           [15:0]      DRAM_DQ;
output           [1:0]      DRAM_DQM;
output                      DRAM_RAS_N;
output                      DRAM_WE_N;

//////////// EPCS //////////
output                      EPCS_ASDO;
input                       EPCS_DATA0;
output                      EPCS_DCLK;
output                      EPCS_NCSO;

//////////// Accelerometer and EEPROM //////////
output                      G_SENSOR_CS_N;
input                       G_SENSOR_INT;
output                      I2C_SCLK;
inout                       I2C_SDAT;

//////////// ADC //////////
output                      ADC_CS_N;
output                      ADC_SADDR;
output                      ADC_SCLK;
input                       ADC_SDAT;

//////////// 2x13 GPIO Header //////////
inout           [12:0]      GPIO_2;
input            [2:0]      GPIO_2_IN;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout           [33:0]      GPIO_0;
input            [1:0]      GPIO_0_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout           [33:0]      GPIO_1;
input            [1:0]      GPIO_1_IN;


//=======================================================
//  REG/WIRE declarations
//=======================================================
reg                         CLOCK_25;

wire                        vjtag_tck;
wire                        vjtag_tdi;
wire                        vjtag_irin;
wire                        vjtag_cdr;
wire                        vjtag_cir;
wire                        vjtag_e1dr;
wire                        vjtag_e2dr;
wire                        vjtag_pdr;
wire                        vjtag_sdr;
wire                        vjtag_udr;
wire                        vjtag_uir;
wire                        vjtag_tdo;
wire             [7:0]      PC_data;
wire                        PC_flag;

reg                         nRst;
reg              [7:0]      reset_count;


wire                        iRXD;
wire             [7:0]      mData;
wire                        mDataReady;
wire             [31:0]     code;
wire                        code_ready;
wire             [7:0]      index;
wire                        index_ready;
wire             [31:0]     tCode;
wire                        trigger_wire;

wire             [7:0]      debug_8;
wire             [31:0]     debug_32;


reg                         Rst;
reg                         trigger;
reg              [31:0]     oCode_Channel;
reg                         RxD;
reg              [7:0]      test;
reg              [7:0]      mData_Channel;
reg                         mDataReady_Channel;
reg              [31:0]     code_Channel;
reg                         code_ready_Channel;
reg              [7:0]      index_channel;
reg                         index_ready_channel;



//=======================================================
//  Structural coding
//=======================================================
/*
always @ (*) begin
    //nRst = KEY[0] && (reset_count==0) && line_reset;
    nRst = KEY[0] && (reset_count==0);
end*/
//assign line_reset = GPIO_0_IN[0];

always @ (posedge CLOCK_50) 
    CLOCK_25 <= !CLOCK_25;
    
async_receiver AR(
    .clk(CLOCK_25),
    .RxD(iRXD),
    .RxD_data_ready(mDataReady),
    .RxD_data(mData),
    .RxD_endofpacket(),
    .RxD_idle()
);

decoder de(
    .iRst(Rst),
    .imData(mData_Channel),
    .imData_Ready(mDataReady_Channel),
    .oCode(code),
    .oCode_Ready(code_ready),
    .oIndex(index),
    .oIndex_Ready(index_ready)
);



ext_code_32ch_256p co(
    .iSET_CODE_FLAG(code_ready_Channel),
    .iSET_CODE(code_Channel),
    .iSET_INDEX_FLAG(index_ready_channel),
    .iSET_INDEX(index_channel),
    .iRst(Rst),
    .iTrigger(trigger_wire),
    .iClk(CLOCK_50),
    .oCode(tCode),
    .debug_index(debug_8),
    .debug_current_storge(debug_32)
);

assign iRXD     = RxD;
assign trigger_wire = trigger;
//assign LED[7:0] = oCode_Channel[7:0];
assign LED = test;
always @ (posedge CLOCK_50)
begin
    test[3:0] <= debug_8[3:0];
    test[7:4] <= tCode[7:4];
end


always @ (posedge CLOCK_50)
begin
    Rst <= ~KEY[1];
    //trigger <= ~KEY[0];
    trigger <=GPIO_0_IN[1];
    oCode_Channel <= tCode;
    RxD <= GPIO_0_IN[0];
    
    mDataReady_Channel <= mDataReady;
    mData_Channel <= mData;
    code_Channel <= code;
    code_ready_Channel <= code_ready;
    index_channel <= index;
    index_ready_channel <= index_ready;
    
end

assign GPIO_0[2] = ~trigger;
assign GPIO_0[4] = 0;

assign GPIO_0[33:30] = ~tCode[19:16]; //10Mhz
assign GPIO_0[29:26] = ~tCode[15:12]; //Mhz
assign GPIO_0[23:20] = ~tCode[11:8]; //100kHz
assign GPIO_0[19:16] = ~tCode[7:4]; //10kHz
assign GPIO_0[15:12] = ~tCode[3:0]; //kHz

endmodule
